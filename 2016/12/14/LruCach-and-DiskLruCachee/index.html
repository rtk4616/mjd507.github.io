<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android 中 Lru 缓存算法分析 | Cleaner</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android 中 Lru 缓存算法分析</h1><a id="logo" href="/.">Cleaner</a><p class="description">life is not a 100-meter race</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/readingList/"><i class="fa fa-th-large"> 读书清单</i></a><a href="/365/"><i class="fa fa-fire"> 365</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android 中 Lru 缓存算法分析</h1><div class="post-meta">Dec 14, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">1.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LruCache"><span class="toc-number">2.</span> <span class="toc-text">LruCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DiskLruCache"><span class="toc-number">3.</span> <span class="toc-text">DiskLruCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非常棒的文章"><span class="toc-number">4.</span> <span class="toc-text">非常棒的文章</span></a></li></ol></div></div><div class="post-content"><p>Android 项目设计到大量 图片，文件时，都会使用到缓存技术，一般项目框架都会帮助我们封装好，我们只需要指定具体的缓存策略就可以了；缓存的策略或者说算法有很多种，比如 FIFO，FILO，LRU 等，本文主要分析一下 LruCache 以及 DiskLruCache。LruCache 在 Android 3.1 之后就出现在 Android 源码中了，DiskLruCache 得到官方推荐，但还未出现在源码里。<a href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html" target="_blank" rel="noopener">查看 DiskLruCache.java 源码</a>，另外，JakeWharton 也有一份 <a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">DiskLruCache</a>，可以看看。</p>
<a id="more"></a>
<p>再看 LruCache 源码之前，有必要先了解一下这个类：LinkedHashMap。LruCache 内部就是使用这个 map 来维护缓存数据的。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>先看一个小栗子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(<span class="string">"021"</span>, <span class="string">"shanghai"</span>);</span><br><span class="line">hashMap.put(<span class="string">"0512"</span>, <span class="string">"suzhou"</span>);</span><br><span class="line">hashMap.put(<span class="string">"010"</span>, <span class="string">"beijing"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(hashMap);</span><br><span class="line"></span><br><span class="line">LinkedHashMap&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">linkedHashMap.put(<span class="string">"021"</span>, <span class="string">"shanghai"</span>);</span><br><span class="line">linkedHashMap.put(<span class="string">"0512"</span>, <span class="string">"suzhou"</span>);</span><br><span class="line">linkedHashMap.put(<span class="string">"010"</span>, <span class="string">"beijing"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(linkedHashMap);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0512</span>=suzhou, <span class="number">021</span>=shanghai, <span class="number">010</span>=beijing&#125;</span><br><span class="line">&#123;<span class="number">021</span>=shanghai, <span class="number">0512</span>=suzhou, <span class="number">010</span>=beijing&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过结果也可以猜到，LinkedHashMap 对内部存储的关系映射数据是有序的。我们看下它的源码，先看它内部的静态类 LinkedEntry ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedEntry adds nxt/prv double-links to plain HashMapEntry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMapEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; nxt;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; prv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create the header entry */</span></span><br><span class="line">    LinkedEntry() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        nxt = prv = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create a normal entry */</span></span><br><span class="line">    LinkedEntry(K key, V value, <span class="keyword">int</span> hash, HashMapEntry&lt;K, V&gt; next,</span><br><span class="line">                LinkedEntry&lt;K, V&gt; nxt, LinkedEntry&lt;K, V&gt; prv) &#123;</span><br><span class="line">        <span class="keyword">super</span>(key, value, hash, next);</span><br><span class="line">        <span class="keyword">this</span>.nxt = nxt;</span><br><span class="line">        <span class="keyword">this</span>.prv = prv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，LinkedEntry 继承了 HashMapEntry，该 Entry 除了保存当前对象的引用外，还同时增加了两个 Entry，prv、nxt 来保存对前一个 和 后一个元素的引用。我们先看它存储数据的方法 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNewEntry</span><span class="params">(K key, V value, <span class="keyword">int</span> hash, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; header = <span class="keyword">this</span>.header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove eldest entry if instructed to do so.</span></span><br><span class="line">    LinkedEntry&lt;K, V&gt; eldest = header.nxt;</span><br><span class="line">    <span class="keyword">if</span> (eldest != header &amp;&amp; removeEldestEntry(eldest)) &#123;</span><br><span class="line">        remove(eldest.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create new entry, link it on to list, and put it into table</span></span><br><span class="line">    LinkedEntry&lt;K, V&gt; oldTail = header.prv;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; newTail = <span class="keyword">new</span> LinkedEntry&lt;K,V&gt;(</span><br><span class="line">            key, value, hash, table[index], header, oldTail);</span><br><span class="line">    table[index] = oldTail.nxt = header.prv = newTail;</span><br></pre></td></tr></table></figure></p>
<p>LinkedHashMap 里没有重写 put 方法，而是重写了 HashMap 的 put 方法调用的子方法 addNewEntry，提供了自己特有的双向链接列表的实现。再看下读取数据的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This method is overridden to eliminate the need for a polymorphic</span></span><br><span class="line"><span class="comment">     * invocation in superclass at the expense of code duplication.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        HashMapEntry&lt;K, V&gt; e = entryForNullKey;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            makeTail((LinkedEntry&lt;K, V&gt;) e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace with Collections.secondaryHash when the VM is fast enough (http://b/8290590).</span></span><br><span class="line">    <span class="keyword">int</span> hash = secondaryHash(key);</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - <span class="number">1</span>)];</span><br><span class="line">            e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        K eKey = e.key;</span><br><span class="line">        <span class="keyword">if</span> (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (accessOrder)</span><br><span class="line">                makeTail((LinkedEntry&lt;K, V&gt;) e);</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面有一个 accessOrder，它是一个 布尔值，true 代表按访问顺序排，false 代表按插入顺序排，默认为 false，在构造函数里可以看到。如果打算按访问顺序（最先访问的在最前面）来保存元素，那么可以用它另一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> LinkedEntry&lt;K, V&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>accessOrder 就为实现 Lru 算法的实现铺好了路。Lru 算法 ： 最少最近使用的对象，正好是基于访问顺序，利用 accessOrder 这一属性就非常简单了，下面就来看看 Lru 算法的实现。</p>
<h2 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h2><p>先看构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用 LruCache 需提供一个缓存的最大的 size，当超过这个 size 就回收；另外，构造了一个 LinkedHashMap，accessOrder 传的值为 true，果然是按访问顺序排序。<br>LruCache 存储和读取的方法都是调用 LinkedHashMap 的方法，这里就不贴了。我们一般使用如下方法来构建一个 LruCache：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cacheSize = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 4MiB</span></span><br><span class="line">LruCache&lt;String, Bitmap&gt; bitmapCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getByteCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h2><p>创建 DiskLruCache：DiskLruCache 构造方法被私有化了，并提供了 open 方法来创建自身。该方法有四个参数，第一个是存储目录，可以选择 SD 卡上的缓存目录，如果想要应用卸载后，此目录数据一并删除，可以这样指定 /sdcard/Android/data/package_name/cache. 第二个参数是应用版本号，一般设为 1，当版本号发生改变时，会清除之前的缓存文件，但实际开发中作用不大，很多情况即使版本号改变了，之前的缓存还在，所以一般设为 1，第三个参数表示单个节点对应的数据的个数，一般也设为 1，第四个参数表示表示缓存的总大小。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"valueCount &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// prefer to pick up where we left off</span></span><br><span class="line">        DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">        <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.readJournal();</span><br><span class="line">                cache.processJournal();</span><br><span class="line">                cache.journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(cache.journalFile, <span class="keyword">true</span>),</span><br><span class="line">                        IO_BUFFER_SIZE);</span><br><span class="line">                <span class="keyword">return</span> cache;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line"><span class="comment">//                System.logW("DiskLruCache " + directory + " is corrupt: "</span></span><br><span class="line"><span class="comment">//                        + journalIsCorrupt.getMessage() + ", removing");</span></span><br><span class="line">                cache.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// create a new empty cache</span></span><br><span class="line">        directory.mkdirs();</span><br><span class="line">        cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">        cache.rebuildJournal();</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>DiskLruCache 在缓存对象的时候，如果 key 是一个 url，最好先用 key 的 md5 值作为新的 key 去缓存，主要是为了避免 url 中的特殊字符的影响。有了 key 之后，通过 edit(key) 方法获取一个 Editor 对象，在通过 这个 Editor 获得输出流，我们从网络下载文件时直接将获得的输入流写到这个 输出流当中，在通过 editor.commit() 方法将流写入文件系统，看下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    String key = MD5Utils.getMd5Str(url.getBytes());</span><br><span class="line">    DiskLruCache.Editor editor = mDiskLrucache.edit(key);</span><br><span class="line">    <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (downloadUrlToStream(url, outputStream)) &#123;</span><br><span class="line">            editor.commit();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            editor.abort();</span><br><span class="line">        &#125;</span><br><span class="line">        mDiskLrucache.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">downloadUrlToStream</span><span class="params">(String url, OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">    URL urlStr = <span class="keyword">null</span>;</span><br><span class="line">    HttpURLConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">    BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        urlStr = <span class="keyword">new</span> URL(url);</span><br><span class="line">        conn = (HttpURLConnection) urlStr.openConnection();</span><br><span class="line">        out = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line">        in = <span class="keyword">new</span> BufferedInputStream(conn.getInputStream());</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        CloseUtils.closeIO(in, out);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，下次再获取该文件就不要走网络请求了。 DiskLruCache 缓存的查找和添加过程类似，首先 通过 get(key) 方法获取一个 Snapshot 对象，通过它获取到文件的输入流，有了 输入流，如果是一个图片，就可以通过 BitmapFactory.decodeStream() 来获取到 bitmap 对象了。但为了避免 oom，需要对图片进行压缩处理，这里有一个问题，FileInputStream 是一种有序的文件流，如果 decodeStream 两次，会影响文件流的位置属性，导致第二次 decodeStream 时，返回的是 null。解决办法是通过文件流得到对应的文件描述，然后通过 BitmapFactory.decodeFileDescriptor 来加载一张缩略图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">get</span><span class="params">(String url,<span class="keyword">int</span> reqWidth,<span class="keyword">int</span> reqHeight)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">    String key = MD5Utils.getMd5Str(url.getBytes());</span><br><span class="line">    DiskLruCache.Snapshot snapshot = mDiskLrucache.get(key);</span><br><span class="line">    <span class="keyword">if</span>(snapshot!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        FileInputStream fis = (FileInputStream) snapshot.getInputStream(<span class="number">0</span>);</span><br><span class="line">        FileDescriptor fileDescriptor = fis.getFD();</span><br><span class="line">        bitmap = ImageResizer.decodeSampledBitmapFromDescriptor(fileDescriptor, reqWidth, reqHeight);</span><br><span class="line">        <span class="comment">//add to memory</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，应该对 DiskLruCache 如何使用有了一个了解。</p>
<h2 id="非常棒的文章"><a href="#非常棒的文章" class="headerlink" title="非常棒的文章"></a>非常棒的文章</h2><p><a href="http://zhangshixi.iteye.com/blog/673789" target="_blank" rel="noopener">LinkedHashMap的实现原理</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/28863651" target="_blank" rel="noopener">Android DiskLruCache完全解析，硬盘缓存的最佳方案</a></p>
<p><br></p>
<p><br></p>
<p><strong>声明 ：本站主要是用来整理不懂的知识，大部分内容我都没有完全掌握，请谨慎参考。</strong><br><strong>版权 ：可以转载，但请在文章显著位置注明出处 ！ <a href="https://mjd507.github.io">https://mjd507.github.io</a></strong></p>
</div><div class="tags"></div><div class="post-nav"><a href="/2016/12/20/View-MotionEvent-dispatch-And-Sliding-Conflict/" class="pre">View 的 事件分发体系 及 滑动冲突解决方案</a><a href="/2016/12/13/Java-Reference/" class="next">谈谈 Java 的引用类型</a></div><div id="container"></div><!-- link(rel='stylesheet', type='text/css', href='//unpkg.com/gitalk/dist/gitalk.css')--><link rel="stylesheet" type="text/css" href="/css/gitalk-night.css"><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script><script>var path_name = location.pathname;

// 解决普通文章在微信浏览器中 url 上自动添加参数的问题
var path_rule = path_name.match(/\/\d{4}\/\d{2}\/\d{2}\/[^\/]+\//);
if(path_rule && path_rule[0])
  path_name = path_rule[0]
else
  //解决菜单文章在微信浏览器中 url 上自动添加参数的问题
  var path_rule_2 = path_name.match(/\/[^\/]+\//);
    if(path_rule_2 && path_rule_2[0])
      path_name = path_rule_2[0]

var gitalk = new Gitalk({
  clientID: 'fa8d49cc90698365347d',
  clientSecret: 'ad101f458b7f3950fccc09b931977c106cd2c467',
  repo: 'mjd507.github.io',
  owner: 'mjd507',
  admin: ['mjd507'],
  id: md5(path_name),
  distractionFreeMode: 'false',
})
gitalk.render('container')</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure/">Data Structure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DesignPattern/">DesignPattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web 前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Internet-Protocol/">网络相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life-in-lianhuaguoji/">莲花国际的日子</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/Java-8-lambda-intro/">Java8 中的 lambda 表达式入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/Java-Volatile-Keyword/">Java 中的 Volatile 关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/13/JDK-7-Try-With-Resource/">JDK 7 中的 Try-With-Resource</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/09/Java-slf4j-intro/">Java 日志框架 slf4j</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/Test-Comment/">Test-Comment</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/02/Java-Annotation/">Java 注解入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Java-Buffer-IO/">IO 流的一些优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/16/HTTP-Cache/">HTTP 缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/09/HTTPS-vs-SSH/">SSH 使用以及与 HTTPS 的对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/30/HTTP-Security/">HTTPS 安全机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://johnnyshieh.me/" title="JohnnyShieh" target="_blank">JohnnyShieh</a><ul></ul><a href="https://daimajia.com/" title="代码家" target="_blank">代码家</a><ul></ul><a href="http://javayhu.me/" title="宅男潇涧" target="_blank">宅男潇涧</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Cleaner.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a> Theme modify by <a rel="nofollow" target="_blank" href="https://github.com/mjd507"> mjd507.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1c847d4fb515d19b6108f15a5387f1d6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>